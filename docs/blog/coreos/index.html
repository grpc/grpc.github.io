<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://cjyabraham.github.io/grpccss/style.css">
    <title>
  gRPC with REST and Open APIs &ndash; gRPC
</title>
  </head>
  <body>

    <div id="landing-content">
      <div class="row">
        <div class="topbannersub">
          <div class="logonav">
                <img src="https://cjyabraham.github.io/grpcimg/grpc-logo.png" style="width:10%">
            </div>
            <div class="topnav">
                <a href="https://cjyabraham.github.io/grpcabout/">About</a>
		<a href="https://cjyabraham.github.io/grpcdocs/">Docs</a>
		<a href="https://cjyabraham.github.io/grpcblog/">Blog</a> 
		<a href="https://cjyabraham.github.io/grpccommunity/">Community</a>
		<a href="https://packages.grpc.io/">Packages</a> 
		<a href="https://cjyabraham.github.io/grpcfaq/">FAQ</a>
            </div>
    
            <div class="headertext">Blog</div>
  </div>
        </div>
        </div>

  <div class="singleblog"> 
  <h3 style="margin-top:0px;">gRPC with REST and Open APIs</h3>
  <h5>Posted on Monday, May 09, 2016 by Brandon Phillips</h5>
  <p>
    <p>Our guest post today comes from Brandon Phillips of <a href="https://coreos.com/">CoreOS</a>. CoreOS builds open source projects and products for Linux Containers. Their flagship product for consensus and discovery <a href="https://coreos.com/etcd/">etcd</a> and their container engine <a href="https://coreos.com/rkt/">rkt</a> are early adopters of gRPC.</p>

<p>One of the key reasons CoreOS chose gRPC is because it uses HTTP/2, enabling applications to present both a HTTP 1.1 REST/JSON API and an efficient gRPC interface on a single TCP port (available for Go). This provides developers with compatibility with the REST web ecosystem, while advancing a new, high-efficiency RPC protocol. With the recent release of Go 1.6, Go ships with a stable <code>net/http2</code> package by default.</p>

<p></p>

<p>Since many CoreOS clients speak HTTP 1.1 with JSON, gRPC&rsquo;s easy interoperability with JSON and the <a href="https://github.com/OAI/OpenAPI-Specification">Open API Specification</a> (formerly Swagger) was extremely valuable. For their users who are more comfortable with HTTP/1.1+JSON-based and Open API Spec APIs they used a combination of open source libraries to make their gRPC services available in both gRPC and HTTP REST flavors, using API multiplexers to give users the best of both worlds. Let&rsquo;s dive into the details and find out how they did it!</p>

<p><em>This post was originally published at the <a href="https://coreos.com/blog/gRPC-protobufs-swagger.html">CoreOS blog</a>. We are reproducing it here with some edits.</em></p>

<h2 id="a-grpc-application-called-echoservice">A gRPC application called EchoService</h2>

<p>In this post we will build a small proof-of-concept gRPC application from a gRPC API definition, add a REST service gateway, and finally serve it all on a single TLS port. The application is called EchoService, and is the web equivalent of the shell command echo: the service returns, or &ldquo;echoes&rdquo;, whatever text is sent to it.</p>

<p>First, let’s define the arguments to EchoService in a protobuf message called EchoMessage, which includes a single field called value. We will define this message in a protobuf &ldquo;.proto&rdquo; file called <code>service.proto</code>. Here is our EchoMessage:</p>

<pre><code class="language-proto">message EchoMessage {
 string value = 1;
}
</code></pre>

<p>In this same .proto file, we define a gRPC service that takes this data structure and returns it:</p>

<pre><code class="language-proto">service EchoService {
  rpc Echo(EchoMessage) returns (EchoMessage) {
  }
}
</code></pre>

<p>Running this <code>service.proto</code> file &ldquo;as is&rdquo; through the Protocol Buffer compiler <code>protoc</code> generates a stub gRPC service in Go, along with clients in various languages. But gRPC alone isn’t as useful as a service that also exposes a REST interface, so we won’t stop with the gRPC service stub.</p>

<p>Next, we add the gRPC REST Gateway. This library will build a RESTful proxy on top of the gRPC EchoService. To build this gateway, we add metadata to the EchoService .proto to indicate that the Echo RPC maps to a RESTful POST method with all RPC parameters mapped to a JSON body. The gateway can map RPC parameters to URL paths and query parameters, but we omit those complications here for brevity.</p>

<pre><code class="language-proto">service EchoService {
  rpc Echo(EchoMessage) returns (EchoMessage) {
    option (google.api.http) = {
      post: &quot;/v1/echo&quot;
      body: &quot;*&quot;
    };
  }
}
</code></pre>

<p>This means the gateway, once generated by <code>protoc</code>, can now accept a HTTP request from <code>curl</code> like this:</p>

<pre><code>curl -X POST -k https://localhost:10000/v1/echo -d '{&quot;value&quot;: &quot;CoreOS is hiring!&quot;}'
</code></pre>

<p>The whole system so far looks like this, with a single <code>service.proto</code> file generating both a gRPC server and a REST proxy:</p>

<p><img src="/img/grpc-rest-gateway.png" class="img-responsive" alt="gRPC API with REST gateway"></p>

<p>To bring this all together, the echo service creates a Go <code>http.Handler</code> to detect if the protocol is HTTP/2 and the Content-Type is &ldquo;application/grpc&rdquo;, and sends such requests to the gRPC server. Everything else is routed to the REST gateway. The code looks something like this:</p>

<pre><code class="language-go">if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
	grpcServer.ServeHTTP(w, r)
} else {
	otherHandler.ServeHTTP(w, r)
}
</code></pre>

<p>To try it out, all you need is a working Go 1.6 development environment and the following simple commands:</p>

<pre><code>$ go get -u github.com/philips/grpc-gateway-example
$ grpc-gateway-example serve
</code></pre>

<p>With the server running you can try requests on both HTTP 1.1 and gRPC interfaces:</p>

<pre><code>grpc-gateway-example echo Take a REST from REST with gRPC
curl -X POST -k https://localhost:10000/v1/echo -d '{&quot;value&quot;: &quot;CoreOS is hiring!&quot;}'
</code></pre>

<p>One last bonus: because we have an Open API specification, you can browse the Open API UI running at <code>https://localhost:10000/swagger-ui/#!/EchoService/Echo</code> if you have the server above running on your laptop.</p>

<p><img src="/img/grpc-swaggerscreen.png" class="img-responsive" alt="gRPC/REST Open API document"></p>

<p>We’ve taken a look at how to use gRPC to bridge to the world of REST. If you want to take a look at the complete project, check out the <a href="https://github.com/philips/grpc-gateway-example">repo on GitHub</a>. We think this pattern of using a single protobuf to describe an API leads to an easy to consume, flexible API framework, and we’re excited to leverage it in more of our projects.</p>
  </p>


  </div>

    
    
  </body>
</html>
