---
layout: post
title: Announcing out of the box support for gRPC in the Flatbuffers serializaton library.
published: true
permalink: blog/flatbuffers
author: Wouter van Oortmerssen
company: Google
company-link: https://www.google.com
---

The recent release of Flatbuffers [version 1.7](https://github.com/google/flatbuffers/releases) introduced truly zero-copy support for gRPC out of the box. 

[Flatbuffers](https://google.github.io/flatbuffers/) is a serialization library that allows you to access serialized data without first unpacking it or allocating any 
additional data structures. It was originally designed for games and other resource constrained applications, but is now finding use
within many teams at Google, and outside (eg: Facebook, Netflix).

<!--more-->

Flatbuffers enables maximum throughput by directly using gRPC's slice buffers with zero-copy for the common use cases. An incoming rpc may be processed directly from gRPCs internal buffers, and you constructing new message will write directly to internal buffers without intermediate steps.

So far, this is supported in the C++ implementation of FlatBuffers. There is also an implementation in Go, which is not entirely zero copy, but still very low on allocation cost (see below). Other languages are in the works.


### Example Usage

Start with an .fbs schema (similar to .proto, if you are familiar with protocol buffers) that declares an RPC service:

#### Use Flatbuffers as an IDL

```
table HelloReply {
  message:string;
}

table HelloRequest {
  name:string;
}

table ManyHellosRequest {
  name:string;
  num_greetings:int;
}

rpc_service Greeter {
  SayHello(HelloRequest):HelloReply;
  SayManyHellos(ManyHellosRequest):HelloReply (streaming: "server");
}
```

This can be compiled with: `flatc --cpp --grpc example.fbs` to get generated C++ code, much like in protocol buffers.

#### Generated Server Implementation
The server implementation is very similar to protocol buffers, except now the request and response messages are of type `flatbuffers::grpc::Message<HelloRequest> *`. 
Unlike protocol buffers, where these types represent a tree of C++ objects, here they are merely handles to a flat object in the underlying gRPC slice. You can access the data directly:

```
auto request = request_msg->GetRoot();
auto name = request->name()->str();
```

Building a response is equally simple
```
auto msg_offset = mb_.CreateString("Hello, " + name);
auto hello_offset = CreateHelloReply(mb_, msg_offset);
mb_.Finish(hello_offset);
*response_msg = mb_.ReleaseMessage<HelloReply>();
```

The client code is the same as that generated by protocol buffers, except for the FlatBuffer access and construction code.


See the full example [here](https://github.com/google/flatbuffers/tree/master/grpc/samples/greeter). To compile it, you need gRPC as before. 
Read about using and building FlatBuffers for your platform [here](https://google.github.io/flatbuffers/).

For Go there is a similar test [here](https://github.com/google/flatbuffers/blob/master/grpc/tests/go_test.go).
